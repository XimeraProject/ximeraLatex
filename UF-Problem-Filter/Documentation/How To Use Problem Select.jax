\newenvironment {prompt}{}{}
\newcommand {\DeclareMathOperator }[2]{\@OldDeclareMathOperator {##1}{##2}\immediate \write \myfile {\unexpanded {\DeclareMathOperator }{\unexpanded {##1}}{\unexpanded {##2}}}}
\newcommand {\vb@xt@ }[0]{\vbox to}
\newcommand {\Gm@vrules@mpi }[0]{\hb@xt@ \@tempdima {\llap {\Gm@vrule }\ignorespaces \hskip \textwidth \Gm@vrule \hskip \marginparsep \llap {\Gm@vrule }\hfil \Gm@vrule }}
\newcommand {\Gm@vrules@mpii }[0]{\hb@xt@ \@tempdima {\hskip -\marginparwidth \hskip -\marginparsep \llap {\Gm@vrule }\ignorespaces \hskip \marginparwidth \rlap {\Gm@vrule }\hskip \marginparsep \llap {\Gm@vrule }\hskip \textwidth \rlap {\Gm@vrule }\hss }}
\newcommand {\Gm@pageframes }[0]{\vb@xt@ \z@ {\ifGm@showcrop \vb@xt@ \z@ {\vskip -1\Gm@truedimen in\vskip \Gm@layoutvoffset \hb@xt@ \z@ {\hskip -1\Gm@truedimen in\hskip \Gm@layouthoffset \vb@xt@ \Gm@layoutheight {\let \protect \relax \hb@xt@ \Gm@layoutwidth {\Gm@cropmark (-1,1,-3,3)\hfil \Gm@cropmark (1,1,3,3)}\vfil \hb@xt@ \Gm@layoutwidth {\Gm@cropmark (-1,-1,-3,-3)\hfil \Gm@cropmark (1,-1,3,-3)}}\hss }\vss }\fi \ifGm@showframe \if@twoside \ifodd \count \z@ \let \@themargin \oddsidemargin \else \let \@themargin \evensidemargin \fi \fi \moveright \@themargin \vb@xt@ \z@ {\vskip \topmargin \vb@xt@ \z@ {\vss \Gm@hrule }\vskip \headheight \vb@xt@ \z@ {\vss \Gm@hruled }\vskip \headsep \vb@xt@ \z@ {\vss \Gm@hrule }\@tempdima \textwidth \advance \@tempdima by \marginparsep \advance \@tempdima by \marginparwidth \if@mparswitch \ifodd \count \z@ \Gm@vrules@mpi \else \Gm@vrules@mpii \fi \else \Gm@vrules@mpi \fi \vb@xt@ \z@ {\vss \Gm@hrule }\vskip \footskip \vb@xt@ \z@ {\vss \Gm@hruled }\vss }\fi }}
\newcommand {\geometry }[1]{\Gm@clean \setkeys {Gm}{##1}\Gm@process }
\newcommand {\Gm@changelayout  }[0]{\setlength {\@colht }{\textheight } \setlength {\@colroom }{\textheight }\setlength {\vsize }{\textheight } \setlength {\columnwidth }{\textwidth }\if@twocolumn \advance \columnwidth -\columnsep \divide \columnwidth \tw@ \@firstcolumntrue \fi \setlength {\hsize }{\columnwidth }\setlength {\linewidth }{\hsize }}
\newcommand {\newgeometry }[1]{\clearpage \Gm@restore@org \Gm@initnewgm \Gm@newgmtrue \setkeys {Gm}{##1}\Gm@newgmfalse \Gm@process \ifnum \mag =\@m \else \Gm@magtooffset \fi \Gm@changelayout \Gm@showparams {newgeometry}}
\newcommand {\restoregeometry }[0]{\clearpage \Gm@restore@pkg \Gm@changelayout }
\newcommand {\savegeometry }[1]{\Gm@save \expandafter \edef \csname Gm@restore@@##1\endcsname {\Gm@restore }}
\newcommand {\loadgeometry }[1]{\clearpage \@ifundefined {Gm@restore@@##1}{\PackageError {geometry}{\string \loadgeometry : name `##1' undefined}{The name `##1' should be predefined with \string \savegeometry }}{\@nameuse {Gm@restore@@##1}\Gm@changelayout }}
\newcommand {\TagList@CatGeneral }[0]{{Cat@One,Cat@Two,Cat@Three,Cat@Four,Cat@Five} }
\newcommand {\TagList@MasterCatOne }[0]{{Ans@MC, Ans@ShortAns, Ans@MultiAns, Ans@FRQ, Ans@Match, Ans@Graph, Ans@Table} }
\newcommand {\TagList@MasterCatTwo }[0]{{Type@Compute, Type@Concept, Type@Approximate, Type@Tutorial} }
\newcommand {\TagList@MasterCatThree }[0]{{Topic@Limit, Topic@Derivative, Topic@Integral, Topic@Lim-Imp, Topic@Int-Imp, Topic@Derv-Imp, Topic@Lim-Mult, Topic@Int-Mult, Topic@Derv-Mult} }
\newcommand {\TagList@MasterCatFour }[0]{{Sub@Poly, Sub@Exp, Sub@Log, Sub@Trig, Sub@Arctrig, Sub@Piecewise, Sub@Rational, Sub@Radical, Sub@Disc-Remove, Sub@Disc-Inf, Sub@Disc-Jump, Sub@Asymptote, Sub@Continuity, Sub@Domain, Sub@Tan-Line, Sub@RoC, Sub@Avg-RoC, Sub@Differential, Sub@Method-Log, Sub@Extrema-Local, Sub@Extrema-Absolute, Sub@Critical-Number, Sub@Related-Rates, Sub@Multi-Deriv, Sub@Optimization, Sub@Inflection, Sub@Riemann, Sub@Sub-u, Sub@Definite, Sub@Indefinite, Sub@Power-Rule, Sub@Chain-Rule, Sub@Product-Rule, Sub@Quotient-Rule, Sub@Theorems-IVT, Sub@Theorems-MVT, Sub@Theorems-FTC, Sub@Theorems-EVT, Sub@LHopital, Sub@Squeeze, Sub@Formal-Def, Sub@Implicit, Sub@DifferenceQuotient, Sub@LimitLaws, Sub@Sign-Graph, Sub@Motion, Sub@Symmetry, Sub@OneSided, } }
\newcommand {\TagList@MasterCatFive }[0]{{Question@Number} }
\newcommand {\QBank@loc }[0]{/home/jason/texmf/tex/Questions/}
\newcommand {\file@Write }[2]{ \expandafter \immediate \expandafter \write \csname ##1\endcsname {##2} }
\newcommand {\file@Initialize }[1]{ \expandafter \newwrite \csname ##1\endcsname \expandafter \immediate \expandafter \openout \csname ##1\endcsname =file-\jobname --ProblemList-##1.tex }
\newcommand {\question@SetKeys }[1]{ \setkeys {key@ProblemSelect}{PerFile={}, Static={}, Shuffle={}, GroupShuffle={},##1} }
\newcommand {\inner@SetKeys }[1]{ \setkeys {key@Inner}{InnerShuffle={}, Order@Direction={},##1} }
\newcommand {\latexProblemContent }[1]{\stepcounter {Question@CurNumber}\ifveryVerbose We are checking problem \arabic {Question@CurNumber}. \\ \fi \ifnum \value {Problem@RemainToCheck}>1\par \ifVerbose Registered the last question to be: \arabic {Problem@ToList}\\ Registered the Current question to be: \arabic {Question@CurNumber}\\ \fi \par \ifVerbose Looking for question \arabic {Problem@NextRef}.\\ \fi \par \ifnum \value {Question@CurNumber}=\value {Problem@NextRef}\ifVerbose I think I found question \arabic {Problem@NextRef} so I am assigning a new command now.\\ \fi \stepcounter {Question@DisplayCounter}\expandafter \newcommand \csname Question@Display\roman {Problem@GroupingNumber}\Roman {Question@DisplayCounter}\endcsname {##1 } \file@Write {\Roman {file@GroupRef}}{\unexpanded {##1}} \ifVerbose I assigned the command to be Question@Display\roman {Problem@GroupingNumber}\Roman {Question@DisplayCounter} in theory.\\ \fi \addtocounter {Problem@RemainToCheck}{-1}\addtocounter {Problem@EndRef}{-1}\ifnum \value {Problem@EndRef}>0\ifVerbose I think found and properly assigned question \arabic {Problem@NextRef}\\ \fi \setcounter {Problem@NextRef}{\arabic {Question@Location\Roman {Problem@EndRef}}} \ifVerbose Now I'm looking for problem \arabic {Problem@NextRef}\\ \fi \fi \fi \fi \ifveryVerbose The current problem is \arabic {Question@CurNumber}.\\ The Current number of remaining problems is \arabic {Problem@EndRef}.\\ The next problem to find is \arabic {Problem@NextRef}.\\ \fi }
\newcommand {\ProblemFileHeader }[1]{\ifquestionCount \addtocounter {Total@Question}{##1} \fi \ifPerFileQ \setcounter {Total@Question}{##1} \questionPulltrue \ifVerbose We should now be Pulling Questions (questionPulltrue)\\ \fi \addtocounter {Problem@ToList}{\arabic {Given@ProblemNumber}} \ChooseQuestions {\arabic {Given@ProblemNumber}} \problemToFindtrue \ifVerbose There is a question to Find (questionFindtrue)\\ \fi \par \else \ifVerbose The end ref is currently \arabic {Problem@EndRef}.\\ \fi \par \ifnum \value {Problem@EndRef}>0\par \ifquestionPull \ifVerbose We are now checking that this file contains problems in our range. \\ \fi \par \setcounter {Problem@Range}{\arabic {Question@CurNumber}}\addtocounter {Problem@Range}{##1}\par \ifnum \value {Problem@Range}>\value {Problem@NextRef} \problemToFindtrue \ifVerbose There is a question to Find (questionFindtrue)\\ \fi \else \addtocounter {Question@CurNumber}{##1} \fi \fi \fi \fi }
\newcommand {\ProblemFileFooter }[0]{\problemToFindfalse \ifPerFileQ \setcounter {Question@CurNumber}{0} \questionPullfalse \fi }
\newcommand {\ChooseQuestions }[1]{\make@Vector [Order@Direction=reverse]{Question@Location}{1}{\arabic {Total@Question}}{##1}\par \questionPulltrue \ifVerbose We should now be Pulling Questions (questionPulltrue)\\ \fi \setcounter {Problem@RemainToCheck}{\arabic {Given@ProblemNumber}} \setcounter {Problem@EndRef}{\arabic {Given@ProblemNumber}} \stepcounter {Problem@RemainToCheck} \setcounter {Problem@NextRef}{\arabic {Question@Location\Roman {Problem@EndRef}}} \ifVerbose Problems That Remain to Check \arabic {Problem@RemainToCheck}\\ End Reference pointer: \arabic {Problem@EndRef}\\ I think our first problem is \arabic {Problem@NextRef}\\ I think our ending reference is \arabic {Problem@EndRef}\\ \fi \par }
\newcommand {\@genrand }[3]{ \expandafter \pgfmathrandominteger \csname ##1\endcsname {##2}{##3} \setcounter {##1}{\csname ##1\endcsname } }
\newcommand {\Master@Input@Test }[0]{\ifVerbose I tried to run Master Input Test \fi \par \SearchForTag {Topic@Limit}{ \ifVerbose I detected that I should input the Limit-Input file \ifquestionCount in order to get question counts!\\ \else in order to find problems!\\ \fi \fi \expandafter \input {\QBank@loc Limit-Input} } \par \SearchForTag {Topic@Derivative}{ \ifVerbose I detected that I should input the Derivative-Input file \ifquestionCount in order to get question counts!\\ \else in order to find problems!\\ \fi \fi \expandafter \input {\QBank@loc Derivative-Input} } \par \SearchForTag {Topic@Integral}{ \ifVerbose I detected that I should input the Integral-Input file \ifquestionCount in order to get question counts!\\ \else in order to find problems!\\ \fi \fi \expandafter \input {\QBank@loc Integral-Input} } \par \SearchForTag {Topic@Sequence}{ \ifVerbose I detected that I should input the Sequence-Input file \ifquestionCount in order to get question counts!\\ \else in order to find problems!\\ \fi \fi \expandafter \input {\QBank@loc Sequence-Input} } \par \SearchForTag {Topic@Series}{ \ifVerbose I detected that I should input the Series-Input file \ifquestionCount in order to get question counts!\\ \else in order to find problems!\\ \fi \fi \expandafter \input {\QBank@loc Series-Input} } \par \par }
\newcommand {\select@Question }[1]{ \ifVerbose \ifquestionCount We called the file ##1 to find problem counts!\\ \else We called the file ##1, this time to find problems!\\ \fi \fi \input {##1} }
\newcommand {\Make@Counter }[1]{ \@ifundefined {c@##1} { \newcounter {##1} } { \setcounter {##1}{0} } }
\newcommand {\QSelectEnd }[0]{ \setcounter {Total@Question}{0}\setcounter {Problem@ToList}{0} \setcounter {Question@CurNumber}{0} \stepcounter {file@GroupRef} \questionCounttrue \questionPullfalse \question@Staticfalse \PerFileQfalse \QSShufflefalse }
\newcommand {\findQuestion }[4]{ \findingQuestiontrue \par \set@RelaxActiveTags {} \set@StrictActiveTags {} \par \ifthenelse {\isempty {##1}} { \expandafter \addTo@RelaxActiveTags \TagList@MasterCatOne } { \addTo@RelaxActiveTags {##1} } \par \ifthenelse {\isempty {##2}} { \expandafter \addTo@RelaxActiveTags \TagList@MasterCatTwo } { \addTo@RelaxActiveTags {##2} } \par \ifthenelse {\isempty {##3}} { \expandafter \addTo@RelaxActiveTags \TagList@MasterCatThree } { \addTo@RelaxActiveTags {##3} } \par \ifthenelse {\isempty {##4}} { \expandafter \addTo@RelaxActiveTags \TagList@MasterCatFour } { \addTo@StrictActiveTags {##4} } \Master@Input@Test \par \findingQuestionfalse }
\newcommand {\reserved@a }[2]{}
\newcommand {\reserved@a }[2]{}
\newcommand {\HyperFirstAtBeginDocument }[0]{\AtBeginDocument }
\newcommand {\reserved@a }[1]{}
\newcommand {\reserved@a }[2]{}
\newcommand {\AppendGraphicsExtensions }[0]{\@ifundefined {Gin@extensions}{\let \Gin@extensions \@empty }{}\@ifstar {\grfext@Append \grfext@Check }{\grfext@Append \grfext@@Add }}
\newcommand {\PrependGraphicsExtensions }[0]{\@ifundefined {Gin@extensions}{\let \Gin@extensions \@empty }{}\@ifstar {\grfext@Prepend \grfext@Check }{\grfext@Prepend \grfext@@Add }}
\newcommand {\RemoveGraphicsExtensions }[1]{\@ifundefined {Gin@extensions}{\def \Gin@extensions {}}{\edef \grfext@tmp {\zap@space ##1 \@empty }\@for \grfext@ext :=\grfext@tmp \do {\def \grfext@next {\let \grfext@tmp \Gin@extensions \@expandtwoargs \@removeelement \grfext@ext \Gin@extensions \Gin@extensions \ifx \grfext@tmp \Gin@extensions \let \grfext@next \relax \fi \grfext@next }\grfext@next }}\grfext@Print \RemoveGraphicsExtensions }
\newcommand {\epstopdfsetup }[0]{\setkeys {ETE}}
\newcommand {\epstopdfcall }[1]{\ifETE@InsideSetfile \expandafter \@firstoftwo \else \expandafter \@secondoftwo \fi {`##1}{\Gin@base \Gin@ext }}
\newcommand {\epstopdfDeclareGraphicsRule }[4]{\ifx \\##4\\\@PackageError {epstopdf-base}{Conversion command is missing}\@ehc \else \begingroup \@ifundefined {Gin@rule@##1}{}{\@PackageInfo {epstopdf-base}{Redefining graphics rule for `##1'}}\endgroup \@namedef {Gin@rule@##1}####1{{##2}{##3}{\epstopdfcall {##4}}}\fi }
\newcommand {\ST@wsf }[1]{\immediate \write \ST@sf {##1}}
\newcommand {\mdf@patchamsthm }[0]{\let \mdf@deferred@thm@head \deferred@thm@head \pretocmd {\deferred@thm@head }{\@inlabelfalse }{\mdf@PackageInfo {mdframed detected package amsthm 
 changed the theorem header of amsthm\MessageBreak }}{\mdf@PackageError {mdframed detected package amsthm 
 changed the theorem header of amsthm failed\MessageBreak }}}
\newcommand {\GetTitleStringSetup }[0]{\setkeys {gettitlestring}}
\newcommand {\GetTitleString }[0]{\ifGTS@expand \expandafter \GetTitleStringExpand \else \expandafter \GetTitleStringNonExpand \fi }
\newcommand {\GetTitleStringExpand }[1]{\def \GetTitleStringResult {##1}\begingroup \GTS@DisablePredefinedCmds \GTS@DisableHook \edef \x {\endgroup \noexpand \def \noexpand \GetTitleStringResult {\GetTitleStringResult }}\x }
\newcommand {\GetTitleStringNonExpand }[1]{\def \GetTitleStringResult {##1}\global \let \GTS@GlobalString \GetTitleStringResult \begingroup \GTS@RemoveLeft \GTS@RemoveRight \endgroup \let \GetTitleStringResult \GTS@GlobalString }
\newcommand {\GTS@DisableHook }[0]{}
\newcommand {\label@hook }[0]{}
\newcommand {\@currentlabelname }[0]{}
\newcommand {\reserved@a }[0]{}
\newcommand {\@safe@activestrue }[0]{}
\newcommand {\@safe@activesfalse }[0]{}
\newcommand {\nameref  }[0]{\@ifstar \T@nameref \T@nameref }
\newcommand {\Sectionformat }[2]{##1}
\newcommand {\vnameref  }[1]{\unskip ~\nameref {##1}\@vpageref [\unskip ]{##1}}
\newcommand {\ref  }[0]{\@ifstar \@refstar \T@ref }
\newcommand {\pageref  }[0]{\@ifstar \@pagerefstar \T@pageref }
\newcommand {\nameref  }[0]{\@ifstar \@namerefstar \T@nameref }
\newcommand {\reserved@a }[2]{}
\newcommand {\reserved@a }[2]{}
\newcommand {\reserved@a }[0]{\AtBeginDocument }
\newcommand {\reserved@a }[1]{}
\newcommand {\reserved@a }[2]{}
